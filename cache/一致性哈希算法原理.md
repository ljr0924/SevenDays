# 一致性哈希算法原理

#### 问题背景

简单求取 Hash 值解决了缓存性能的问题，但是没有考虑节点数量变化的场景。假设，移除了其中一台节点，只剩下 9 个，那么之前 `hash(key) % 10` 变成了 `hash(key) % 9`，也就意味着几乎缓存值对应的节点都发生了改变。即几乎所有的缓存值都失效了。节点在接收到对应的请求时，均需要重新去数据源获取数据，容易引起 `缓存雪崩`。

> 缓存雪崩：缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。常因为缓存服务器宕机，或缓存设置了相同的过期时间引起。

#### 原理

> 一致性哈希算法将key映射到2^32的空间中，将这个数字收尾相连，形成一个环。

* 计算节点/机器（通常使用节点的名称，编号，ip地址）的哈希值，放置在环上。
* 计算key的哈希值，放置在环上，顺时针寻找到的第一个节点，就是应选取的节点/机器

![一致性哈希](/Users/banana/git_project/SevenDays/cache/image/一致性哈希.jpeg)

环上有peer2，peer4，peer6节点，key11，key2，key27映射到peer2节点，key23映射到peer4节点。此时，如果新增机器或节点peer8，假设它新增位置如图所示，那么只有key27需要从peer2调整到peer8，其余节点均不需要变动。

也就是说，一致性哈希算法，在新增或删除节点的时候，只需要重新定位该几点附近的一小部分数据，而不需要重新定位所有的节点，这就解决了上述问题

#### 数据倾斜问题

如果服务器节点过少，容易引起key的倾斜。例如上面例子中，有3个key分布在peer2，而peer6是空的。那么映射在环的下半部分，key过度向peer2倾斜，缓存节点间负载不均。

为了解决这个问题，引入了虚拟节点的概念，一个真实节点对应多个虚拟节点

假设1个真实节点对应3个虚拟节点，那么peer1对应的虚拟节点是peer1-1，peer1-2，peer1-3（通常以编号区分），其余节点也以相同方式操作。

1. 计算虚拟节点的hash值，放置在环上
2. 计算key的hash值，在环上顺时针选取对应的虚拟节点，然后通过映射选取对应真实节点

虚拟节点扩充了节点的数量，解决了节点较少的情况下数据容易倾斜的问题，而且代价非常小，只需要增加一个字典（map），维护真实节点与虚拟节点的映射关系即可